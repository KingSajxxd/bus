-- 1. Create a table for 'routes'
-- This just stores the names of your routes, like "Route A", "Route B"
CREATE TABLE routes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Create a table for 'buses'
-- This stores the bus itself, its live location, and links it to a driver
CREATE TABLE buses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL, -- e.g., "Bus-01"
  driver_id UUID REFERENCES auth.users(id) UNIQUE, -- Links to a user
  route_id BIGINT REFERENCES routes(id), -- Links to a route
  live_lat FLOAT8, -- Simpler than PostGIS for a beginner
  live_lng FLOAT8,
  live_status TEXT DEFAULT 'Offline' -- "Offline", "On-Route", "SOS"
);

-- 3. Create a table for 'students'
-- This is the master list of all students
CREATE TABLE students (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  student_uid TEXT NOT NULL UNIQUE, -- The ID from the NFC/QR card
  name TEXT NOT NULL,
  parent_id UUID REFERENCES auth.users(id), -- Links to a user
  route_id BIGINT REFERENCES routes(id) -- Links to a route
);

-- 4. Create the 'attendance_log'
-- This is the same as our test, but links to the new students table
CREATE TABLE attendance_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  student_id BIGINT REFERENCES students(id),
  status TEXT NOT NULL, -- "ON BUS" or "OFF BUS"
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- 5. Create a 'profiles' table for user roles
-- This is critical! It stores *what kind* of user is logging in.
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL -- 'admin', 'driver', or 'parent'
);

-- This magic function will automatically create a profile when you create a new user
CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, role)
  VALUES (new.id, new.raw_user_meta_data->>'role');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- This "trigger" runs the function every time a new user signs up
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

ALTER TABLE public.profiles ALTER COLUMN role DROP NOT NULL;


-- 1. Add 'name' and 'email' columns to our profiles table
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS name TEXT,
ADD COLUMN IF NOT EXISTS email TEXT;

-- 2. This is an UPDATED trigger function.
-- It will now copy the user's email AND the 'name' and 'role'
-- from our sign-up form into the new profiles row.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, name, role)
  VALUES (
    new.id,
    new.email, -- Copies the email from auth.users
    new.raw_user_meta_data->>'name', -- Copies the 'name' from our form
    new.raw_user_meta_data->>'role'  -- Copies the 'role' from our form
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. THIS IS THE FIX:
-- We DROP the old trigger first, so we don't get an error.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- 4. Now we create it again, attached to the new function.
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 1. First, remove the old foreign key constraint that points to auth.users
-- Note: The constraint name might be slightly different in your project. 
-- If this fails, check the actual name in Table Editor > buses > Constraints.
ALTER TABLE public.buses
DROP CONSTRAINT IF EXISTS buses_driver_id_fkey; 

-- 2. Now, add the CORRECT foreign key constraint, pointing to profiles
ALTER TABLE public.buses
ADD CONSTRAINT buses_driver_id_fkey 
FOREIGN KEY (driver_id) REFERENCES public.profiles(id);


-- 1. First, remove the old foreign key constraint that points to auth.users
-- Note: Again, the constraint name might be slightly different. 
-- Check Table Editor > students > Constraints if this fails.
ALTER TABLE public.students
DROP CONSTRAINT IF EXISTS students_parent_id_fkey; 

-- 2. Now, add the CORRECT foreign key constraint, pointing to profiles
ALTER TABLE public.students
ADD CONSTRAINT students_parent_id_fkey 
FOREIGN KEY (parent_id) REFERENCES public.profiles(id);


-- 1. Add a 'last_seen' timestamp to the buses table
-- This helps us know if a bus is truly 'Offline' or just hasn't reported recently
ALTER TABLE public.buses
ADD COLUMN IF NOT EXISTS last_seen TIMESTAMPTZ;

-- 2. (Optional but recommended) Add an index for faster lookups by role
CREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role);

-- Note: We don't need to explicitly add 'principal' to the 'role' column,
-- as TEXT columns can store any string. We just need to handle it in our app code.

-- Adds a new, unique column to your profiles table
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS driver_nfc_uid TEXT UNIQUE;